export const philosophies = [
  {
    "id": "semantic-directive-enhancement",
    "title": "Semantic Directive Enhancement",
    "description": "Core philosophy and architectural principles for the modern Angular CDK.",
    "order": "1",
    "content": "<h3>The Semantic Directives Approach</h3>\n<p>The BaseNative framework completely reimagines how Angular applications interface with the DOM. Instead of encapsulating native functionality within opaque custom components (e.g., <code>&lt;bn-button&gt;</code>), we strictly enforce a <strong>Directive-First Architecture</strong>.</p>\n<h4>1. Semantic HTML First</h4>\n<p>We respect the browser&#39;s built-in accessibility and keyboard navigation features by extending native elements.</p>\n<ul>\n<li><strong>Bad</strong>: <code>&lt;bn-button label=&quot;Submit&quot;&gt;&lt;/bn-button&gt;</code> - Hides the button implementation, harder to style, accessibility requires transparent forwarding.</li>\n<li><strong>Good</strong>: <code>&lt;button variant=&quot;primary&quot; type=&quot;submit&quot;&gt;Submit&lt;/button&gt;</code> - Fully accessible, standard Events, easy to style.</li>\n</ul>\n<h4>2. Platform Over Polyfill</h4>\n<p>We prioritize platform-native APIs over heavy JavaScript libraries.</p>\n<ul>\n<li><strong>Floating UI</strong>: We use the native CSS <strong>Anchor Positioning API</strong> (with polyfills only where strictly required) instead of shipping 50kb of positioning JS.</li>\n<li><strong>Dialogs &amp; Popovers</strong>: We leverage <code>&lt;dialog&gt;</code> and the <strong>Popover API</strong> for top-layer interactions.</li>\n<li><strong>Inert</strong>: We use the <code>inert</code> attribute for focus trapping instead of custom focus-manager services.</li>\n</ul>\n<h4>3. Signal-Native State</h4>\n<p>All directives are built from the ground up using <strong>Angular Signals</strong>.</p>\n<ul>\n<li><strong>Zoneless</strong>: Designed to work without <code>zone.js</code>, relying on <code>signal</code> updates to trigger fine-grained DOM changes.</li>\n<li><strong>Performance</strong>: Change detection is local to the directive, not the entire component tree.</li>\n</ul>\n<h4>4. Structural Styling</h4>\n<p>We reject utility-class soup (e.g., <code>class=&quot;btn btn-primary p-4 rounded-lg&quot;</code>). Instead, we use <strong>Structural CSS</strong>.</p>\n<ul>\n<li>Styles are applied via attribute selectors: <code>button[variant] { ... }</code>.</li>\n<li>Variants are controlled via host binding: <code>[variant=&quot;ghost&quot;]</code>.</li>\n<li>This keeps templates clean and semantic.</li>\n</ul>\n"
  },
  {
    "id": "modular-buildable-architecture",
    "title": "Modular & Buildable Architecture",
    "description": "Complete workspace structure for building a semantic HTML-first component library.",
    "order": "2",
    "content": "<h3>Systems Engineering for Frontend</h3>\n<p>BaseNative treats the frontend workspace not as a single &quot;App&quot;, but as a <strong>Federation of Libraries</strong>. This encourages strict boundaries, faster CI times, and enforced modularity.</p>\n<h4>1. The Library Hierarchy</h4>\n<p>We strictly enforce a one-way dependency graph:</p>\n<ol>\n<li><strong><code>libs/tokens</code></strong>: The &quot;Physics&quot; of the world. Pure CSS/JSON. No Angular.</li>\n<li><strong><code>libs/ui/primitives</code></strong>: Dumb directives. No business logic. (<code>button[variant]</code>, <code>input[text]</code>).</li>\n<li><strong><code>libs/ui/glass</code></strong>: The &quot;Theme&quot; layer. composes primitives into a specific aesthetic.</li>\n<li><strong><code>libs/features/*</code></strong>: Smart business domains. (<code>auth</code>, <code>dashboard</code>, <code>editor</code>).</li>\n<li><strong><code>apps/*</code></strong>: The entry point. only contains routing and configuration.</li>\n</ol>\n<h4>2. Modern Defaults</h4>\n<p>The workspace is configured for the future of web development:</p>\n<ul>\n<li><strong>ESBuild</strong>: Instant builds and HMR. No Webpack.</li>\n<li><strong>Standalone</strong>: No NgModules. Every component is self-contained.</li>\n<li><strong>Strict Mode</strong>: <code>strictTemplates</code> and <code>strictPropertyInitialization</code> are non-negotiable.</li>\n</ul>\n<h4>3. Progressive Enhancement</h4>\n<p>We build for the latest browsers first.</p>\n<ul>\n<li>We implement <strong>CSS Nesting</strong>, <strong>Layers</strong>, and <strong>Container Queries</strong>.</li>\n<li>We use the <code>:has()</code> selector for parent-based logic.</li>\n<li>Fallbacks are minimal and documented.</li>\n</ul>\n<h4>4. Tooling-First Development</h4>\n<p>We don&#39;t write boilerplate. We generate it.</p>\n<ul>\n<li><strong>Generators</strong>: Custom Nx generators create libraries, components, and directives with the correct prefixes and tags automatically.</li>\n<li><strong>Linting</strong>: Custom ESLint rules prevent importing &quot;Smart&quot; features into &quot;Dumb&quot; UI libraries.</li>\n</ul>\n"
  },
  {
    "id": "testing-philosophy",
    "title": "Testing Philosophy",
    "description": "The four types of tests used in the BaseNative workspace to ensure code quality and reliability.",
    "order": "3",
    "content": "<h3>The Pyramid of Confidence</h3>\n<p>We believe in a balanced testing strategy that optimizes for <strong>Confidence per Minute</strong>.</p>\n<h4>1. Static Analysis (Real-time)</h4>\n<p>The first line of defense is not a test, but the compiler.</p>\n<ul>\n<li><strong>TypeScript Strict Mode</strong>: Eliminates entire classes of null-pointer bugs.</li>\n<li><strong>ESLint</strong>: Enforces architectural boundaries (e.g., &quot;Feature A cannot import Feature B&quot;).</li>\n<li><strong>Prettier</strong>: Removes all discussions about code formatting.</li>\n</ul>\n<h4>2. Unit Tests (The Foundation)</h4>\n<p>We use <strong>Jest</strong> to test individual units logic in isolation.</p>\n<ul>\n<li><strong>Focus</strong>: Pure functions, Services, and Directive inputs/outputs.</li>\n<li><strong>Mocking</strong>: External dependencies are mocked to ensure speed.</li>\n<li><strong>Coverage</strong>: We aim for 100% branch coverage on library logic.</li>\n</ul>\n<h4>3. Integration Tests (The Glue)</h4>\n<p>We verify that units play nicely together using <code>ComponentFixture</code>.</p>\n<ul>\n<li><strong>Focus</strong>: Does the <code>button[variant]</code> change style when the <code>ThemeService</code> emits a signal?</li>\n<li><strong>Realism</strong>: We use real child components where possible, shallow rendering only when necessary.</li>\n</ul>\n<h4>4. E2E Tests (The User)</h4>\n<p>We use <strong>Playwright</strong> component testing for visual and interaction verification.</p>\n<ul>\n<li><strong>Visual Regression</strong>: comparing screenshots to ensure pixel-perfect rendering of the Glass theme.</li>\n<li><strong>Interactions</strong>: Clicking real buttons in a real headless browser.</li>\n<li><strong>Cross-Browser</strong>: Verifying that the Anchor Positioning polyfill works in Safari.</li>\n</ul>\n"
  }
];