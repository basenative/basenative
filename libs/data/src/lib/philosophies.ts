export const philosophies = [
  {
    "id": "semantic-directive-enhancement",
    "title": "Semantic Directive Enhancement",
    "description": "Core philosophy and architectural principles for the modern Angular CDK.",
    "order": "1",
    "content": "<h3>The Semantic Directives Approach</h3>\n<p>The BaseNative framework completely reimagines how Angular applications interface with the DOM. Instead of encapsulating native functionality within opaque custom components (e.g., <code>&lt;bn-button&gt;</code>), we strictly enforce a <strong>Directive-First Architecture</strong>.</p>\n<h4>1. Semantic HTML First</h4>\n<p>We respect the browser&#39;s built-in accessibility and keyboard navigation features by extending native elements.</p>\n<ul>\n<li><strong>Bad</strong>: <code>&lt;bn-button label=&quot;Submit&quot;&gt;&lt;/bn-button&gt;</code> - Hides the button implementation, harder to style, accessibility requires transparent forwarding.</li>\n<li><strong>Good</strong>: <code>&lt;button variant=&quot;primary&quot; type=&quot;submit&quot;&gt;Submit&lt;/button&gt;</code> - Fully accessible, standard Events, easy to style.</li>\n</ul>\n<h4>2. Platform Over Polyfill</h4>\n<p>We prioritize platform-native APIs over heavy JavaScript libraries.</p>\n<ul>\n<li><strong>Floating UI</strong>: We use the native CSS <strong>Anchor Positioning API</strong> (with polyfills only where strictly required) instead of shipping 50kb of positioning JS.</li>\n<li><strong>Dialogs &amp; Popovers</strong>: We leverage <code>&lt;dialog&gt;</code> and the <strong>Popover API</strong> for top-layer interactions.</li>\n<li><strong>Inert</strong>: We use the <code>inert</code> attribute for focus trapping instead of custom focus-manager services.</li>\n</ul>\n<h4>3. Signal-Native State</h4>\n<p>All directives are built from the ground up using <strong>Angular Signals</strong>.</p>\n<ul>\n<li><strong>Zoneless</strong>: Designed to work without <code>zone.js</code>, relying on <code>signal</code> updates to trigger fine-grained DOM changes.</li>\n<li><strong>Performance</strong>: Change detection is local to the directive, not the entire component tree.</li>\n</ul>\n<h4>4. Structural Styling</h4>\n<p>We reject utility-class soup (e.g., <code>class=&quot;btn btn-primary p-4 rounded-lg&quot;</code>). Instead, we use <strong>Structural CSS</strong>.</p>\n<ul>\n<li>Styles are applied via attribute selectors: <code>button[variant] { ... }</code>.</li>\n<li>Variants are controlled via host binding: <code>[variant=&quot;ghost&quot;]</code>.</li>\n<li>This keeps templates clean and semantic.</li>\n</ul>\n"
  },
  {
    "id": "testing-philosophy",
    "title": "Testing Philosophy",
    "description": "The four types of tests used in the BaseNative workspace to ensure code quality and reliability.",
    "order": "3",
    "content": "<h3>The Pyramid of Confidence</h3>\n<p>We believe in a balanced testing strategy that optimizes for <strong>Confidence per Minute</strong>.</p>\n<h4>1. Static Analysis (Real-time)</h4>\n<p>The first line of defense is not a test, but the compiler.</p>\n<ul>\n<li><strong>TypeScript Strict Mode</strong>: Eliminates entire classes of null-pointer bugs.</li>\n<li><strong>ESLint</strong>: Enforces architectural boundaries (e.g., &quot;Feature A cannot import Feature B&quot;).</li>\n<li><strong>Prettier</strong>: Removes all discussions about code formatting.</li>\n</ul>\n<h4>2. Unit Tests (The Foundation)</h4>\n<p>We use <strong>Jest</strong> to test individual units logic in isolation.</p>\n<ul>\n<li><strong>Focus</strong>: Pure functions, Services, and Directive inputs/outputs.</li>\n<li><strong>Mocking</strong>: External dependencies are mocked to ensure speed.</li>\n<li><strong>Coverage</strong>: We aim for 100% branch coverage on library logic.</li>\n</ul>\n<h4>3. Integration Tests (The Glue)</h4>\n<p>We verify that units play nicely together using <code>ComponentFixture</code>.</p>\n<ul>\n<li><strong>Focus</strong>: Does the <code>button[variant]</code> change style when the <code>ThemeService</code> emits a signal?</li>\n<li><strong>Realism</strong>: We use real child components where possible, shallow rendering only when necessary.</li>\n</ul>\n<h4>4. E2E Tests (The User)</h4>\n<p>We use <strong>Playwright</strong> component testing for visual and interaction verification.</p>\n<ul>\n<li><strong>Visual Regression</strong>: comparing screenshots to ensure pixel-perfect rendering of the Glass theme.</li>\n<li><strong>Interactions</strong>: Clicking real buttons in a real headless browser.</li>\n<li><strong>Cross-Browser</strong>: Verifying that the Anchor Positioning polyfill works in Safari.</li>\n</ul>\n"
  },
  {
    "id": "asset-pipeline",
    "title": "Single Source of Truth (Asset Pipeline)",
    "description": "Vector authority, zero binary commits, and JIT generation.",
    "content": "<h2>6. Single Source of Truth (Asset Pipeline)</h2>\n<ul>\n<li><strong>Vector Authority</strong>: The workspace maintains exactly ONE master branding asset: <code>libs/data/src/assets/logo.svg</code> (or app-specific <code>logo.svg</code>).</li>\n<li><strong>Binary Zero-Commit Policy</strong>: No generated binary assets (PNG, ICO, webmanifest) are ever committed to Git.</li>\n<li><strong>Just-In-Time Generation</strong>: All platform-specific assets (favicons, PWA icons, OG images) are generated dynamically during the build process using a Playwright-driven rendering engine. This ensures pixel-perfect consistency across all devices without repository bloat.</li>\n<li><strong>Transient Public Directory</strong>: The <code>public/</code> directory is treated as a transient build artifact. It is strictly excluded from Git and populated automatically before the Angular build copies its contents to the distribution folder.</li>\n</ul>\n"
  },
  {
    "id": "documentation-strategy",
    "title": "Documentation & Content Strategy",
    "description": "Distillation workflow and systems engineering mindset.",
    "content": "<h2>5. Documentation &amp; Content Strategy</h2>\n<h3>YAML Distillation Workflow</h3>\n<p>To maintain a &quot;distilled&quot; documentation experience, BaseNative uses a specific workflow for philosophical and conceptual content:</p>\n<ol>\n<li><strong>Drafting</strong>: Technical deep-dives are initially captured in long-form Markdown (<code>.md</code>).</li>\n<li><strong>Distillation</strong>: Relevant principles are extracted into concise, single-sentence statements.</li>\n<li><strong>YAML Conversion</strong>: These statements are moved into <code>.yml</code> files with structured front matter for use in the dynamic documentation site.</li>\n<li><strong>Technical Completeness</strong>: Contrary to &quot;minimal distillation,&quot; documentation must maintain <strong>technical completeness</strong>. The YAML source should explain the &quot;Why&quot; and &quot;How&quot; in depth to provide a &quot;Pro Tier&quot; developer experience.</li>\n<li><strong>Runtime Ingestion</strong>: Articles are served as static assets and fetched at runtime via <code>HttpClient</code>, allowing for a decoupled, manifest-driven documentation delivery system without complex build-time code generation.</li>\n</ol>\n<h3>Systems Engineering Mindset</h3>\n<p>BaseNative isn&#39;t just a component library; it&#39;s a design system intended to scale across a monorepo.</p>\n<ul>\n<li><strong>Global over Local</strong>: Solve problems at the library level (<code>libs/</code>) so they are automatically inherited by any application (<code>apps/</code>).</li>\n<li><strong>Apps as Skins</strong>: The <code>apps/</code> directory should only contain minimal configuration and routing logic. All features and business logic must be abstracted into buildable libraries to ensure maximum reusability and testability.</li>\n<li><strong>Reusable Primitives</strong>: Build small, focused primitives that can be composed into complex features.</li>\n<li><strong>Strict Source Separation</strong>: Consistent directory structures and file separation (TS/HTML/CSS) are non-negotiable for system-wide predictability.</li>\n</ul>\n"
  },
  {
    "id": "modular-buildable-architecture",
    "title": "Modular & Buildable Architecture",
    "description": "Isolation, defined tokens, and progressive enhancement.",
    "content": "<h2>2. Modular &amp; Buildable Architecture</h2>\n<ul>\n<li><strong>Library Isolation</strong>: Organized into discrete, buildable libraries (core, tokens, primitives, forms, layout) within an Nx monorepo.</li>\n<li><strong>DTCG-First Tokens</strong>: Design tokens are defined in a JSON file (<code>tokens.json</code>) following the Design Tokens Community Group (DTCG) standard. This JSON is the single source of truth for both code and design tools (Figma Sync).</li>\n<li><strong>Modern Defaults</strong>: Standardizes on standalone APIs, esbuild, and zoneless Angular.</li>\n<li><strong>Progressive Enhancement</strong>: Use feature detection to provide modern CSS-first paths with necessary fallbacks.</li>\n<li><strong>Tooling-First</strong>: Strict TypeScript, linting, and Nx generators.</li>\n</ul>\n"
  },
  {
    "id": "semantic-architecture",
    "title": "Semantic & Attribute-Based Architecture",
    "description": "Semantic HTML first, zero div policy, and host-level styling.",
    "content": "<h2>1. Semantic &amp; Attribute-Based Architecture</h2>\n<ul>\n<li><strong>Semantic HTML First (Zero Div/Span Policy)</strong>: Native elements (e.g., <code>&lt;button&gt;</code>, <code>&lt;dialog&gt;</code>, <code>&lt;article&gt;</code>, <code>&lt;section&gt;</code>, <code>&lt;fieldset&gt;</code>) are the primary building blocks. The use of <code>&lt;div&gt;</code> and <code>&lt;span&gt;</code> is strictly discouraged and should only be used as a last resort when no semantic alternative exists.</li>\n<li><strong>Host-Level Semantic Selectors</strong>: Components MUST use attribute-based selectors paired with the appropriate native tag (e.g., <code>article[card-item]</code>, <code>section[app-root]</code>, <code>header[nav-rail]</code>). This avoids &quot;element bloat&quot; and ensures the component <em>is</em> the building block in the DOM.</li>\n<li><strong>Host Bindings over Wrapper Divs</strong>: Use the <code>host</code> property in the <code>@Component</code> decorator to apply ARIA roles, labels, and semantic attributes directly to the host element, eliminating the need for internal wrapper divs just for accessibility metadata.</li>\n<li><strong>Style the Host</strong>: Do not use wrapper <code>div</code>s (like <code>.container</code>) inside component templates. Apply all layout, padding, and structural styling directly to the component host using <code>:host</code> in the SCSS file.</li>\n<li><strong>Zero Prefixes</strong>: No <code>mat-</code>, <code>cdk-</code>, or custom library prefixes. Use attributes for variants. <em>Note: This intentionally bypasses standard Angular selector prefix linting in favor of semantic HTML.</em></li>\n<li><strong>Platform over Polyfill</strong>: Use native CSS features like Anchor Positioning, Popover API, and the <code>inert</code> attribute.</li>\n<li><strong>Signal-Native Architecture</strong>: Built from the ground up with Angular Signals (<code>input</code>, <code>output</code>, <code>model</code>) and zoneless change detection.</li>\n<li><strong>Zero Class Styling</strong>: Avoid &quot;class soup.&quot; Use <code>:host</code> and structural selectors (e.g., <code>:host &gt; header</code>, <code>:host &gt; section &gt; article</code>) combined with CSS nesting. Use <code>:has()</code> for contextual styling.</li>\n<li><strong>Clean Component Logic (No Inline Markup/Styles)</strong>: All components MUST use <code>templateUrl</code> and <code>styleUrl</code>. Inline <code>template</code> or <code>styles</code> properties in the <code>@Component</code> decorator are forbidden to ensure compatibility with HTML formatters (Prettier) and clear separation of concerns.</li>\n<li><strong>No Inline Styles (<code>style=&quot;...&quot;</code>)</strong>: Direct use of the <code>style</code> attribute in HTML templates is strictly forbidden.</li>\n</ul>\n"
  },
  {
    "id": "testing-lifecycle",
    "title": "Testing & Lifecycle (CTFD)",
    "description": "Conversational Test-First Development and strict verification.",
    "content": "<h2>4. Testing &amp; Lifecycle (CTFD)</h2>\n<ul>\n<li><strong>Conversational Test-First Development (CTFD)</strong>: The conversation is the primary design artifact. Intent is compiled into a shared contract: a human-readable ticket (task + plan) and executable specs (Gherkin scenarios).</li>\n<li><strong>Test-First Architecture</strong>: Development starts with Gherkin feature files (<code>.feature</code>) and Playwright test specs (or component unit tests mapping to scenarios). Implementation is complete only when all scenarios pass.</li>\n<li><strong>Gherkin Continuity</strong>: Use Cucumber/Gherkin to define both user-facing requirements and automated test logic. This ensures documentation and code are locked in the same &quot;semantic cycle.&quot;</li>\n<li><strong>Mock-First Integration</strong>: External dependencies (API calls, browser APIs like <code>matchMedia</code>) must be mocked at the library level (<code>test-setup.ts</code>) to ensure the build pipeline remains decoupled and performant.</li>\n<li><strong>Verification before Push</strong>: No code is pushed to the repository without a full workspace <code>build</code> and <code>test</code> run (<code>run-many</code>). Stale caches are cleared explicitly (<code>nx reset</code>) to prevent &quot;Phantom Success.&quot;</li>\n</ul>\n"
  },
  {
    "id": "visual-ux-excellence",
    "title": "Visual & UX Excellence",
    "description": "Apple-level polish, motion-first, and JS-native control.",
    "content": "<h2>3. Visual &amp; UX Excellence</h2>\n<ul>\n<li><strong>Apple-Level Polish</strong>: High-quality typography (Inter/system stacks), balanced whitespace, and subtle shadows.</li>\n<li><strong>Motion-First</strong>: Every interaction should feel fluid using standardized easing (e.g., <code>cubic-bezier(0.21, 1.02, 0.48, 1)</code>).</li>\n<li><strong>Responsive &amp; Accessible</strong>: Use of <code>clamp()</code> for typography and semantic HTML for built-in accessibility.</li>\n<li><strong>Theming</strong>: First-class support for dark mode using <strong>JS-Native control</strong>. Toggling is driven by a <code>ThemeService</code> that manages the <code>.dark</code> class on the root element, bypassing conflicting CSS media queries to ensure manual overrides always &quot;win&quot; over system preferences.</li>\n</ul>\n"
  }
];